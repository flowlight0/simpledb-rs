use std::str::FromStr;
use super::ast;

grammar;

pub Statement: ast::Statement = {
    <q:Query> => ast::Statement::Query(q),
    <c:UpdateCommand> => ast::Statement::UpdateCommand(c),
}

Query: ast::QueryCommand = {
    "SELECT" <fs:Comma<IdToken>> "FROM" <ts:Comma<IdToken>> "WHERE" <p:Predicate> => ast::QueryCommand::new(fs, ts, Some(p)),
    "SELECT" <fs:Comma<IdToken>> "FROM" <ts:Comma<IdToken>> => ast::QueryCommand::new(fs, ts, None),
}

UpdateCommand: ast::UpdateCommand = {
    "INSERT INTO" <t:IdToken> "(" <fs:Comma<IdToken>> ")" "VALUES" "(" <vs:Comma<Constant>> ")" => ast::UpdateCommand::Insert(t, fs, vs),
    "DELETE FROM" <t:IdToken> => ast::UpdateCommand::Delete(t, None),
    "DELETE FROM" <t:IdToken> "WHERE" <p:Predicate> => ast::UpdateCommand::Delete(t, Some(p)),
    "MODIFY" <t:IdToken> "SET" <f:IdToken> "=" <e:Expression> => ast::UpdateCommand::Modify(t, f, e, None),
    "MODIFY" <t:IdToken> "SET" <f:IdToken> "=" <e:Expression> "WHERE" <p:Predicate> => ast::UpdateCommand::Modify(t, f, e, Some(p)),
    <c:CreateCommand> => ast::UpdateCommand::Create(c),
}

CreateCommand: ast::CreateCommand = {
    "CREATE TABLE" <t:IdToken> "(" <ds:Comma<FieldDefinition>> ")" => ast::CreateCommand::Table(t, ds),
    "CREATE VIEW" <t:IdToken> "AS" <q:Query> => ast::CreateCommand::View(t, q),
    "CREATE INDEX" <t:IdToken> "ON" <n:IdToken> "(" <f:IdToken> ")" => ast::CreateCommand::Index(t, n, f),
}

FieldDefinition: ast::FieldDefinition = {
    <n:IdToken> <t:FieldType> => ast::FieldDefinition::new(n, t),
}

FieldType: ast::FieldType = {
    "INT" => ast::FieldType::I32,
    "VARCHAR" "(" <i:I32Constant> ")" => ast::FieldType::VarChar(i as usize),
}

pub Predicate: ast::Predicate = {
    <ts:And<Term>> => ast::Predicate::new(ts),
}

pub Term: ast::Term = {
    <l:Expression> "=" <r:Expression> => ast::Term::EqualityTerm(l, r),
}

Expression: ast::Expression = {
    <i:I32Constant> => ast::Expression::I32Constant(i),
    <s:StringConstant> => ast::Expression::StringConstant(s),
    <t:IdToken> => ast::Expression::FieldExpression(t),
}

Constant: ast::Constant = {
    <i:I32Constant> => ast::Constant::I32(i),
    <s:StringConstant> => ast::Constant::String(s),
}

I32Constant: i32 = {
    r"-?[0-9]+" => i32::from_str(<>).unwrap(),
}

StringConstant: String = {
    r"'[^']+'" => String::from(&<>[1..<>.len()-1].to_string()),
}

IdToken: String = {
    r"[a-zA-Z][a-zA-Z0-9_]+" => String::from(<>),
}


Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v
    }
};


And<T>: Vec<T> = {
    <mut v:(<T> "AND")*> <e:T> => {
        v.push(e);
        v
    }
};

