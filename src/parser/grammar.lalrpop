use std::str::FromStr;
use super::statement;
use super::predicate;
use crate::record::field::{Spec, Value};

grammar;

match {
    r"(?i)SELECT" => SELECT,
    r"(?i)FROM" => FROM,
    r"(?i)WHERE" => WHERE,
    r"(?i)INSERT" => INSERT,
    r"(?i)INTO" => INTO,
    r"(?i)VALUES" => VALUES,
    r"(?i)DELETE" => DELETE,
    r"(?i)MODIFY" => MODIFY,
    r"(?i)SET" => SET,
    r"(?i)CREATE" => CREATE,
    r"(?i)TABLE" => TABLE,
    r"(?i)VIEW" => VIEW,
    r"(?i)INDEX" => INDEX,
    r"(?i)ORDER" => ORDER,
    r"(?i)BY" => BY,
    r"(?i)ON" => ON,
    r"(?i)AS" => AS,
    r"(?i)IS" => IS,
    r"(?i)AND" => AND,
    r"(?i)NULL" => NULL,
    r"(?i)I32" => I32,
    r"(?i)VARCHAR" => VARCHAR,
} else {
    "(" => LPAREN,
    ")" => RPAREN,
    "*" => STAR,
    "/" => SLASH,
    "+" => PLUS,
    "," => COMMA,
    "=" => EQ,
} else {
    r"-?[0-9]+" => I32_LITERAL,
    "-" => MINUS,
    r"'[^']+'" => STRING_LITERAL,
} else {
    r"[a-zA-Z][a-zA-Z0-9_]*" => ID,
} else {
    r"[ \t\n]+" => WHITESPACE,
}

pub Statement: statement::Statement = {
    <q:Query> => statement::Statement::Query(q),
    <c:UpdateCommand> => statement::Statement::UpdateCommand(c),
}

pub Query: statement::QueryData = {
    SELECT <fs:FieldList> FROM <ts:Comma<IdToken>> <p:OptPredicate> <o:OptOrderBy> => match fs {
        Some(fields) => statement::QueryData::new_with_order(fields, ts, p, o),
        None => statement::QueryData::new_all_with_order(ts, p, o),
    },
}

FieldList: Option<Vec<String>> = {
    STAR => None,
    <fs:Comma<IdToken>> => Some(fs),
};

OptPredicate: Option<predicate::Predicate> = {
    WHERE <p:Predicate> => Some(p),
    => None,
};

OptOrderBy: Option<Vec<String>> = {
    ORDER BY <os:Comma<IdToken>> => Some(os),
    => None,
};

pub UpdateCommand: statement::UpdateCommand = {
    INSERT INTO <t:IdToken> LPAREN <fs:Comma<IdToken>> RPAREN VALUES LPAREN <vs:Comma<Constant>> RPAREN => statement::UpdateCommand::Insert(t, fs, vs),
    DELETE FROM <t:IdToken> => statement::UpdateCommand::Delete(t, None),
    DELETE FROM <t:IdToken> WHERE <p:Predicate> => statement::UpdateCommand::Delete(t, Some(p)),
    MODIFY <t:IdToken> SET <f:IdToken> EQ <e:Expression> => statement::UpdateCommand::Modify(t, f, e, None),
    MODIFY <t:IdToken> SET <f:IdToken> EQ <e:Expression> WHERE <p:Predicate> => statement::UpdateCommand::Modify(t, f, e, Some(p)),
    <c:CreateCommand> => statement::UpdateCommand::Create(c),
}

CreateCommand: statement::CreateCommand = {
    CREATE TABLE <t:IdToken> LPAREN <ds:Comma<FieldDefinition>> RPAREN => statement::CreateCommand::Table(t, ds),
    CREATE VIEW <t:IdToken> AS <q:Query> => statement::CreateCommand::View(t, q),
    CREATE INDEX <t:IdToken> ON <n:IdToken> LPAREN <f:IdToken> RPAREN => statement::CreateCommand::Index(t, n, f),
}

FieldDefinition: statement::FieldDefinition = {
    <n:IdToken> <t:FieldType> => statement::FieldDefinition::new(n, t),
}

FieldType: Spec = {
    I32 => Spec::I32,
    VARCHAR LPAREN <i:I32Constant> RPAREN => Spec::VarChar(i as usize),
}

pub Predicate: predicate::Predicate = {
    <ts:And<Term>> => predicate::Predicate::new(ts),
}

pub Term: predicate::Term = {
    <e:Expression> IS NULL => predicate::Term::IsNull(e),
    <l:Expression> EQ <r:Expression> => predicate::Term::Equality(l, r),
}

Expression: predicate::Expression = {
    <e:AddExpr> => e,
}

AddExpr: predicate::Expression = {
    <l:AddExpr> PLUS <r:MulExpr> => predicate::Expression::Add(Box::new(l), Box::new(r)),
    <l:AddExpr> MINUS <r:MulExpr> => predicate::Expression::Sub(Box::new(l), Box::new(r)),
    <e:MulExpr> => e,
}

MulExpr: predicate::Expression = {
    <l:MulExpr> STAR <r:Factor> => predicate::Expression::Mul(Box::new(l), Box::new(r)),
    <l:MulExpr> SLASH <r:Factor> => predicate::Expression::Div(Box::new(l), Box::new(r)),
    <e:Factor> => e,
}

Factor: predicate::Expression = {
    LPAREN <e:Expression> RPAREN => e,
    NULL => predicate::Expression::NullConstant,
    <i:I32Constant> => predicate::Expression::I32Constant(i),
    <s:StringConstant> => predicate::Expression::StringConstant(s),
    <t:IdToken> => predicate::Expression::Field(t),
}

Constant: Value = {
    NULL => Value::Null,
    <i:I32Constant> => Value::I32(i),
    <s:StringConstant> => Value::String(s),
}

I32Constant: i32 = {
    I32_LITERAL => i32::from_str(<>).unwrap(),
}

StringConstant: String = {
    STRING_LITERAL => String::from(&<>[1..<>.len()-1].to_string()),
}

IdToken: String = {
    ID => String::from(<>),
}


Comma<T>: Vec<T> = {
    <mut v:(<T> COMMA)*> <e:T> => {
        v.push(e);
        v
    }
};


And<T>: Vec<T> = {
    <mut v:(<T> AND)*> <e:T> => {
        v.push(e);
        v
    }
};

